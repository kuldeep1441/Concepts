<!-- The main differences between stack and heap memory are:

Memory Allocation:

Stack: Allocated automatically during function calls and deallocated when the function exits. It's used for (static memory allocation).

Heap: Managed manually via malloc, new, or similar functions, and must be freed explicitly. It's used for (dynamic memory allocation).

Access Speed:

Stack: Faster, as memory is organized in a (last-in, first-out (LIFO) structure).
Heap: Slower, as memory blocks are scattered and managed dynamically.

Size:

Stack: (Limited in size), usually smaller than the heap.
Heap: Larger, allowing for more flexible and extensive memory allocation.

Lifetime:

Stack: Memory is automatically managed and released when a function call ends.
Heap: Memory persists until it is explicitly freed by the programmer. like (delete in C++.)

Memory Fragmentation:

Stack: No fragmentation, as memory allocation is contiguous.
Heap: Can suffer from fragmentation as memory blocks are allocated and freed in an unpredictable order. -->




<!-- Internal and External Fragmentation in Stack and Heap
1. Internal Fragmentation
Definition:

Occurs when an allocated memory block is larger than needed, leaving unused space within the block.
Stack:

Occurrence: Rare.
Reason: Memory in the stack is allocated in fixed-size frames for function calls and local variables.
Example:
Minor internal fragmentation can happen due to alignment rules, where a small variable (e.g., char) occupies more space than needed (e.g., 4 bytes due to alignment).
Heap:

Occurrence: More common.
Reason: Dynamic memory allocation on the heap often requires rounding up memory allocations for alignment (e.g., 8 or 16-byte alignment).
Example:
Requesting 10 bytes of memory may result in an allocation of 16 bytes, leading to 6 bytes of unused space.
2. External Fragmentation
Definition:

Occurs when free memory is available but scattered in small, non-contiguous blocks, making it difficult to allocate larger memory blocks despite sufficient total free memory.
Stack:

Occurrence: Does not occur.
Reason: The stack follows a strict LIFO (Last In, First Out) memory allocation and deallocation order. Memory is reclaimed immediately when a function exits, preventing gaps or fragmentation.
Heap:

Occurrence: Common.
Reason: Due to dynamic allocation and deallocation of memory blocks, small free gaps (holes) form over time.
Example:
Allocating 50 bytes, then freeing it, followed by allocating 30 bytes. Later, if a request for 60 bytes comes, the system may not be able to allocate it if memory has become fragmented into small pieces. -->





// data structures allocation in stack or heap

<!-- Stack Allocation:
Primitive data types:

Examples: int, float, char in C/C++.
These are typically allocated on the stack when defined as local variables within a function.
Fixed-size arrays:

Example: int arr[10];
If defined inside a function or block, the array is allocated on the stack.
Structs/Objects (in some languages):

In C++, objects of classes or structs can be stack-allocated if instantiated directly (e.g., MyClass obj;).

Heap Allocation:
Dynamic data structures:

Examples: Linked lists, trees, graphs.
They are allocated on the heap because their size is not known at compile time. For example, nodes in a linked list or tree are dynamically allocated.

Dynamically sized arrays:

Example: int* arr = new int[size]; in C++ or int* arr = malloc(size * sizeof(int)); in C.
These arrays are allocated on the heap.
Objects (in some languages):

In languages like C++ and Java, objects are typically allocated on the heap when using new.
Example in C++: MyClass* obj = new MyClass();
In Java, all objects are heap-allocated.
Containers in STL/Collections:

In C++'s Standard Template Library (STL), containers like std::vector, std::list, and std::map use heap allocation for their elements as they dynamically resize.
Mixed Allocation:
Some objects or arrays can have a combination of stack and heap memory usage. For example, in C++, if you create an object on the stack that contains pointers to dynamically allocated memory (e.g., a pointer to an array), the pointer will be on the stack, but the memory it points to will be on the heap. -->