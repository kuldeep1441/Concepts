Dead Letter Queue (DLQ) – Overview
A Dead Letter Queue (DLQ) is a specialized message queue used in message-driven systems to store messages that cannot be successfully processed by the consumer or target service. Instead of discarding problematic messages, they are routed to the DLQ for later review and handling.

Why Use a DLQ?
DLQs help in:
✅ Preventing Data Loss – Problematic messages are not lost.
✅ Isolating Failures – Keeps the main queue clean for valid messages.
✅ Debugging & Analysis – Allows developers to inspect failed messages.
✅ System Stability – Avoids continuous retries that could overload the system.

When is a Message Sent to a DLQ?
A message is typically moved to a DLQ when:

The consumer fails to process it after multiple retry attempts.
The message is malformed or does not meet the schema.

How DLQ Works
Message Producer sends messages to the main queue.
Consumer processes messages from the main queue.
If the consumer fails to process a message after the allowed retries:
The message is moved to the Dead Letter Queue.

Messages in the DLQ can be:
Manually inspected and fixed.
Reprocessed after correction.

DLQ in Different Systems
AWS SQS → Supports DLQ using Redrive Policy.
Kafka → DLQ is usually implemented as a separate topic (e.g., topic-name.DLQ).
RabbitMQ → DLQ is configured using Alternate Exchange.

DLQ in Instagram’s Like Flow
User → API → Like Service
    ↓
    Redis (update like count)
    ↓
    Kafka Topic: like_events
        ↓
        Consumer (Notification / Feed Service)
            ↓
            If fails after retries → DLQ: like_events.DLQ