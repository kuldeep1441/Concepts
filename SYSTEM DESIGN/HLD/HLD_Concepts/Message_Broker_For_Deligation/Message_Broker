Message Broker in Real-World : for API & Database Systems

Definition
A Message Broker is an intermediary system that enables asynchronous communication between an API server and backend services (such as a database or other microservices). Instead of making direct synchronous calls, the API sends a message to the broker, which later delivers it to consumers for processing.

We do not always need a message broker. It’s used in specific scenarios where (asynchronous processing), decoupling(microservice communication), or scalability is critical.


Why Use It in Real Systems?
**A message broker typically uses a message queue or message stream internally to achieve both of below goals**
Handle High Traffic: Spikes in API requests don’t overload the database directly.
Improve Reliability(Durablity): If the database is down, the broker queues messages for later processing.


Real-World Flow Example:
Scenario: An API endpoint /place-order is called.
Client → API Server
The client sends an order request to the API server.
API Server → Message Broker
The API publishes an “Order Created” message to the message broker (e.g., RabbitMQ, Kafka).
Message Broker → Consumer Service
A consumer service (e.g., Order Processor) reads the message and processes the order.
It then updates the Database (e.g., inserts order details).


Popular Brokers for This Use Case:
**RabbitMQ**: Use message queue for operation.
**Apache Kafka**: High-throughput and use message streams.
Amazon SQS + SNS: Cloud-managed messaging for microservices.


***When to Use a Message Broker vs When Not To***

| **Scenario**                                 | **Use Message Broker?** | **Reason** 
------------------------------------------------------------------------------------------------- |
| **High Traffic / Load Spikes**               | ✅ Yes                   | Broker queues messages and prevents downstream services from being overwhelmed.

| **Asynchronous Tasks**                       | ✅ Yes                   | Tasks like sending emails, notifications, or background processing don’t need immediate response.

| **Microservices Communication**              | ✅ Yes                   | Decouples services so they don’t depend on each other’s availability or endpoints.

| **Event-Driven Systems**                     | ✅ Yes                   | Multiple services can react to the same event independently.

| **Reliability & Retry Needed**               | ✅ Yes                   | Messages are persisted until processed, ensuring no loss.

| **Distributed Systems / Horizontal Scaling** | ✅ Yes                   | Allows consumers to scale independently of producers.

| **Simple CRUD or Monolithic Apps**           | ❌ No                    | Extra infrastructure is unnecessary; direct DB/API calls are simpler.

| **Low-Latency Required**                     | ❌ No                    | Message queuing adds latency; direct calls provide immediate response.

| **Small-Scale / Predictable Traffic**        | ❌ No                    | Overhead of managing a broker isn’t justified.

| **Critical Synchronous Operations**          | ❌ No                    | Operations like login/auth or payment transactions need real-time completion.


**Variaties of Message Broker:** 
(To communicate with 1 service we use message queue and to communcation with more than 1 service use message stream)
| Feature           | Message Queue(single consumer)    | Message Stream(Costly)(multiple consumers) |
| ----------------- | --------------------------------- | ------------------------------------------ |
| Delivery          | communication with 1 service only | Multiple services read the event independently|
| Message retention | Usually removed after consume     | Retained for configurable time             |
| Use case          | Task processing / async jobs      | Event-driven, analytics, replayable events |
| Examples          | RabbitMQ, SQS  (Sending Email)    | Kafka, Pulsar, Redpanda                    |



**Connection Pools Are Used:**
A connection to a broker (e.g., RabbitMQ, Kafka) can be expensive to create, especially if you open and close a connection for every message.
A connection pool maintains a set of reusable connections or channels so producers and consumers can send/receive messages efficiently.
Reduces latency and resource overhead.

| **Component**                 | **Connection Pool Usage**                                     |
| ----------------------------- | ------------------------------------------------------------- |
| **Producer (API server)**     | Maintains a pool of connections/channels to publish messages. |
| **Consumer (Worker/Service)** | Maintains pool to fetch messages from queues efficiently.     |
