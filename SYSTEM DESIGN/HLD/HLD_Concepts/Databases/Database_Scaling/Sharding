Shrading = Splitting a single large dataset into smaller chunks and distributing them across multiple servers (shards).
             or (Horizontal partitioning of one large database across multiple servers for scalability.)

Example of Sharding : 
(
Single Database (Before Sharding):
All 100 GB of data in one server → slow when data grows.

After Sharding:
Data split into (chunks) by shard key (e.g., userId):

Shard 1(server 1) → userId 1–1000
Shard 2 → userId 1001–2000
Shard 3 → userId 2001–3000

Each shard(server) can live on separate hardware, so queries scale horizontally.

When a Query Comes
find userId = 2500 → router sends query to Shard 3 only (faster).
find all users → query goes to all shards and merges results
)
EXAMPLE : Each organisation's data is sharded on teams. (there is 1 shard for each organisation of teams database)

In MonogDB : 

| **Split By**                        |**Type**
| ----------------------------------------------------------------------------------------------------------------------
| **Database / Collections / Tables** | **Functional Partitioning** (often for microservices; **NOT actual sharding**, more like splitting by business domain)

| **Fields / Columns**                | **Vertical Partitioning** (split schema attributes across multiple tables or collections)

| **Documents / Rows**                | **Horizontal Partitioning (Sharding)** (true sharding where each shard holds a subset of rows/documents)


**Why MongoDB Makes Sharding Easier**
Built-in Sharding: MongoDB uses config servers + mongos routers to route queries automatically. MySQL requires manual routing in the app.

Automatic Balancing: MongoDB splits data into chunks and auto-migrates them when shards are unbalanced. MySQL needs manual rebalancing.

No Cross-Shard Joins: MongoDB stores related data in one document → avoids joins. MySQL’s join-heavy design makes sharding complex.

Unique IDs: MongoDB’s ObjectId is globally unique. MySQL’s AUTO_INCREMENT breaks → needs custom ID generation.

Cross-Shard Queries: MongoDB supports them via mongos. MySQL needs the app to merge results.

Resharding: MongoDB can reshard online. MySQL rebalancing is manual and risky.

Schema Flexibility: MongoDB is schema-less, easier across shards. MySQL needs strict schema sync.