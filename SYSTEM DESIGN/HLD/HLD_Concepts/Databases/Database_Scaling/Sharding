Shrading = Splitting a single large dataset into smaller chunks and distributing them across multiple servers (shards).

Example of Sharding : 
(
Single Database (Before Sharding):
All 100 GB of data in one server → slow when data grows.

After Sharding:
Data split into (chunks) by shard key (e.g., userId):

Shard 1(server 1) → userId 1–1000
Shard 2 → userId 1001–2000
Shard 3 → userId 2001–3000

Each shard(server) can live on separate hardware, so queries scale horizontally.
**EXAMPLE : Each organisation's data is sharded on teams. (there is 1 shard for each organisation of teams database)**



**SHARDING VS PARTITIONING**
What is Partitioning?
Partitioning is the process of splitting a single database or table into smaller, logical units called partitions.
All partitions reside on the same server (or database instance).
The database engine decides which partition to scan for a query based on the partition key.

Types of Partitioning :

Horizontal Partitioning (Row-based)
Breaks a table into subsets of rows.
Example:
Partition 1: user_id 1–1,000
Partition 2: user_id 1,001–2,000


Vertical Partitioning (Column-based)
Splits columns into different tables.
Example:
Table 1: user_id, name, email
Table 2: user_id, address, phone


How Partitioning Helps
Improves Query Performance:
Queries only scan the relevant partition instead of the entire table.
Better Data Management: Makes it easier to archive or drop old partitions (e.g., monthly logs).
Load Distribution (to some extent): Partitions can be placed on different storage devices for I/O optimization.
Efficient Maintenance: Index rebuilds and backups can be done on a single partition instead of the whole table.



In MonogDB : 

| **Split By**                        |**Type**
| ----------------------------------------------------------------------------------------------------------------------
| **Database / Collections / Tables** | **Functional Partitioning** (often for microservices; **NOT actual sharding**, more like splitting by business domain)

| **Fields / Columns**                | **Vertical Partitioning** (split schema attributes across multiple tables or collections)

| **Documents / Rows**                | **can be Horizontal Partitioning or (Sharding)** (true sharding where each shard holds a subset of rows/documents)


**Why MongoDB Makes Sharding Easier**
Built-in Sharding: MongoDB uses config servers + mongos routers to route queries automatically. MySQL requires manual routing in the app.

Automatic Balancing: MongoDB splits data into chunks and auto-migrates them when shards are unbalanced. MySQL needs manual rebalancing.

No Cross-Shard Joins: MongoDB stores related data in one document → avoids joins. MySQL’s join-heavy design makes sharding complex.

Unique IDs: MongoDB’s ObjectId is globally unique. MySQL’s AUTO_INCREMENT breaks → needs custom ID generation.

Cross-Shard Queries: MongoDB supports them via mongos. MySQL needs the app to merge results.

Resharding: MongoDB can reshard online. MySQL rebalancing is manual and risky.

Schema Flexibility: MongoDB is schema-less, easier across shards. MySQL needs strict schema sync.
