Synchronous vs Asynchronous vs Async/Await
1. Overview
When building applications, tasks often have dependencies.
Example:
Task A → Fetch data from API
Task B → Process that data
Task C → Save processed data to database

The question is: should these tasks be run synchronously or using async/await?

2. Synchronous Execution
Tasks are executed line by line.
Each task must finish before the next begins.
The program blocks during long operations (e.g., network requests, DB queries, file reads).

Example
const a = taskA(); // blocks until complete
const b = taskB(a); // waits for A
const c = taskC(b); // waits for B
console.log("Final:", c);

Pros
Simple to reason about.
Best for CPU-bound calculations or quick tasks.

Cons
Blocking: Long-running operations freeze the entire program.
Poor scalability for servers (one request can block all others).
Poor UX in frontend (UI becomes unresponsive).

3. Asynchronous Execution
Tasks don’t block the main program.
Long operations run in the background.
Results are handled via callbacks or promises once ready.

Example (Promise-based)
taskA()
  .then(resultA => taskB(resultA))
  .then(resultB => taskC(resultB))
  .then(final => console.log("Final:", final))
  .catch(err => console.error(err));

Pros
Non-blocking → multiple tasks can progress in parallel.
Improves scalability and responsiveness.

Cons
nested promises can reduce readability.

4. Async/Await
Syntactic sugar over promises.
Allows writing asynchronous code in a sequential style.
await pauses the function until the promise resolves, but doesn’t block the entire program.

Example
async function main() {
  const a = await taskA(); // waits, but non-blocking
  const b = await taskB(a);
  const c = await taskC(b);
  console.log("Final:", c);
}

main();

Pros (Don't block the whole world like synchronous do)
Clean and readable (looks synchronous).
Easy error handling with try...catch.
Non-blocking → system remains responsive. 

Cons
Still sequential if written one after another (can be optimized with Promise.all easily if there is no dependency between them).



CALLBACK HELL
Callback hell (also called pyramid of doom) happens when you have multiple asynchronous tasks that depend on each other, and you handle them using nested callbacks.

Dependent tasks (problem starts)
Now say:
Task A → Task B → Task C → Task D (each depends on previous).

doTaskA(function(resultA) {
  doTaskB(resultA, function(resultB) {
    doTaskC(resultB, function(resultC) {
      doTaskD(resultC, function(resultD) {
        console.log("Final result:", resultD);
      });
    });
  });
});



Async/Await vs Promise.all in JavaScript
1. Promises and Settling
A promise represents a future value (pending → fulfilled/rejected).
A promise can settle only once (either fulfilled or rejected).
Many promises can be pending and settling in parallel — JavaScript’s event loop allows multiple async tasks (I/O, timers, network) to run concurrently.

2. Sequential Execution with async/await
async function run() {
  const a = await taskA();  // waits until A settles
  const b = await taskB();  // starts only after A
  const c = await taskC();  // starts only after B
  return [a, b, c];
}


Behavior: Each task starts only after the previous one finishes.
Execution time: Sum of all durations (e.g., 1s + 2s + 3s = 6s).
Use case: When tasks are dependent (output of one is needed for the next).

3. Parallel Execution with Promise.all
async function run() {
  const [a, b, c] = await Promise.all([
    taskA(), // starts immediately
    taskB(), // starts immediately
    taskC()  // starts immediately
  ]);
  return [a, b, c];
}

Behavior: All tasks start at the same time.
Execution time: Equals the longest duration (e.g., max(1s, 2s, 3s) = 3s).
Use case: When tasks are independent.

4. Common Pattern (Start First, Await Later)
async function run() {
  const promiseA = taskA(); // start A
  const promiseB = taskB(); // start B
  const promiseC = taskC(); // start C

  const [a, b, c] = await Promise.all([promiseA, promiseB, promiseC]);
}
Useful when tasks must run in parallel but you want to keep explicit references to their promises.

5. Key Differences
Feature	Sequential (await)	Parallel (Promise.all)
Start time	Next starts after previous	All start immediately
Total duration	Sum of all durations	Longest single duration
Dependencies	Best when dependent	Best when independent
Error handling	Stops on first rejection	Fails fast if any rejects